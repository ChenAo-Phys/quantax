from typing import Union, Sequence, Optional, Tuple
import numpy as np
import jax
import jax.numpy as jnp
from .symmetry import Symmetry
from ..global_defs import PARTICLE_TYPE, get_sites, get_lattice, get_default_dtype


_Identity = None
_Z2Inverse = dict()


def Identity() -> Symmetry:
    """Identity (no symmetry)."""
    global _Identity
    if _Identity is None:
        _Identity = Symmetry()
    return _Identity


def Z2Inversion(eigval: int = 1) -> Symmetry:
    """
    The Z2 inversion symmetry. This represents the spin flip in spin-1/2 systems,
    and the particle-hole symmetry in fermionic systems.

    :param eigval:
        An integer specifying the symmetry sector. The meaning of each number is

        - 1: Eigenvalue 1 after Z2 inversion
        - 0: No Z2 inversion symmetry
        - -1: Eigenvalue -1 after Z2 inversion
    """
    if eigval not in (1, -1):
        raise ValueError("'eigval' of Z2Inversion should be 1 or -1.")

    global _Z2Inverse
    if eigval not in _Z2Inverse:
        _Z2Inverse[eigval] = Symmetry(Z2_inversion=eigval)
    return _Z2Inverse[eigval]


def SpinInverse(eigval: int = 1) -> Symmetry:
    """
    Spin inverse symmetry for both spin-1/2 and spinful fermion systems.
    In spin systems it flips all spins.
    In spinful fermion systems it exchanges particles between spin-up and spin-down sites.

    :param eigval:
        An integer specifying the symmetry sector. The meaning of each number is

        - 1: Eigenvalue 1 after spin inversion
        - 0: No spin inversion
        - -1: Eigenvalue -1 after spin inversion
    """
    sites = get_sites()

    if not sites.is_spinful:
        raise ValueError("The `SpinInverse` is only defined for spinful systems.")

    if sites.is_fermion:
        if eigval == 1:
            sector = 0
        elif eigval == -1:
            sector = 1
        else:
            return Identity()
        N = sites.Nsites
        generator = np.concatenate([np.arange(N, 2 * N), np.arange(N)])
        return Symmetry(generator, sector)
    else:
        return Z2Inversion(eigval)


def ParticleHole(eigval: int = 1) -> Symmetry:
    """
    Particle-hole symmetry for fermion systems.

    :param eigval:
        An integer specifying the symmetry sector. The meaning of each number is

        - 1: Eigenvalue 1 after particle-hole inversion
        - 0: No particle-hole inversion
        - -1: Eigenvalue -1 after particle-hole inversion
    """
    if not get_sites().is_fermion:
        raise RuntimeError("`ParticleHole` symmetry is only for fermion systems.")
    return Z2Inversion(eigval)


def _standardize_coord(coord: np.ndarray) -> np.ndarray:
    lattice = get_lattice()
    basis = lattice.basis_vectors.T
    new_xyz = np.linalg.solve(basis, coord.T).T  # dimension: ni
    is_periodic = lattice.boundary != 0
    shifted_xyz = new_xyz[:, is_periodic]
    extent = np.asarray(lattice.shape)[1:][is_periodic]
    shifted_xyz %= extent
    shifted_xyz[np.isclose(shifted_xyz, extent)] = 0.0
    new_xyz[:, is_periodic] = shifted_xyz
    coord = np.einsum("ij,nj->ni", lattice.basis_vectors, new_xyz)
    return coord


def LinearTransform(
    matrix: np.ndarray,
    center: Optional[np.ndarray] = None,
    sector: int = 0,
    character: Optional[jax.Array] = None,
) -> Symmetry:
    """
    The symmetry generated by a linear transformation to the lattice.

    :param matrix:
        A 2D array for the linear transformation matrix.

    :param center:
        The center of the linear transformation.

    :param sector:
        The symmetry sector.

    :param character:
        The character of the symmetry group elements.
        This is useful when the symmetry sector doesn't have a 1D group representation.

    .. warning::
        The users are responsible to ensure that the linear transformation generates
        a symmetry group.
    """
    lattice = get_lattice()
    if center is None:
        center = np.mean(lattice.coord, axis=0)

    coord = _standardize_coord(lattice.coord)
    new_coord = np.einsum("ij,nj->ni", matrix, lattice.coord - center) + center
    new_coord = _standardize_coord(new_coord)
    match_mat = np.all(np.isclose(coord[:, None, :], new_coord[None, :, :]), axis=-1)

    if ~np.all(np.sum(match_mat, axis=1) == 1):
        raise ValueError("The transformation does not map the lattice to itself.")

    generator = np.argmax(match_mat, axis=1)
    if lattice.particle_type == PARTICLE_TYPE.spinful_fermion:
        generator = np.concatenate([generator, generator + lattice.Nsites])
    return Symmetry(generator, sector, character=character)


def Flip(
    axis: Union[int, Sequence] = 0, center: Optional[np.ndarray] = None, sector: int = 0
) -> Symmetry:
    """
    Flip the lattice in a spatial dimension.

    :param axis:
        The axis to flip the lattice

    :param sector:
        The symmetry sector
    """
    matrix = np.ones(get_lattice().ndim)
    matrix[np.asarray(axis)] = -1
    matrix = np.diag(matrix)
    return LinearTransform(matrix, center, sector)


def Rotation(
    angle: float,
    axes: Sequence = (0, 1),
    center: Optional[np.ndarray] = None,
    sector: int = 0,
    character: Optional[jax.Array] = None,
) -> Symmetry:
    """
    Rotation symmetry.

    :param angle:
        Rotation angle

    :param axes:
        Two rotated axes

    :param center:
        The center of rotation.

    :param sector:
        The symmetry sector.

    :param character:
        The eigenvalue (character) of the symmetry group elements.
        This is useful when the symmetry sector doesn't have a 1D group representation.
    """
    ndim = get_lattice().ndim
    if max(axes) >= ndim:
        raise ValueError(
            f"The rotated axis {max(axes)} is out-of-bound for a {ndim}-D system"
        )
    cos_theta = np.cos(angle)
    sin_theta = np.sin(angle)
    matrix = np.eye(ndim)
    x, y = axes
    matrix[x, x] = cos_theta
    matrix[x, y] = -sin_theta
    matrix[y, x] = sin_theta
    matrix[y, y] = cos_theta
    return LinearTransform(matrix, center, sector, character)


def C4v(center: Optional[np.ndarray] = None, repr: str = "A1") -> Symmetry:
    """
    `C4v <http://symmetry.jacobs-university.de/cgi-bin/group.cgi?group=404&option=4>`_
    symmetry group.

    :param center:
        The center of the symmetry operation.

    :param repr:
        The representation of the group, chosen among 'A1', 'A2', 'B1', 'B2' or 'E'.
    """
    if repr == "A1":
        rot = Rotation(angle=np.pi / 2, center=center, sector=0)
        flip = Flip(center=center, sector=0)
        return rot @ flip
    if repr == "A2":
        rot = Rotation(angle=np.pi / 2, center=center, sector=0)
        flip = Flip(center=center, sector=1)
        return rot @ flip
    if repr == "B1":
        rot = Rotation(angle=np.pi / 2, center=center, sector=2)
        flip = Flip(center=center, sector=0)
        return rot @ flip
    if repr == "B2":
        rot = Rotation(angle=np.pi / 2, center=center, sector=2)
        flip = Flip(center=center, sector=1)
        return rot @ flip
    if repr == "E":
        character = jnp.array([2, -2], get_default_dtype())
        return Rotation(angle=np.pi, center=center, character=character)
    raise ValueError(
        "'repr' should be one of the following: 'A1', 'A2', 'B1', 'B2' or 'E'"
    )


def D6(center: Optional[np.ndarray] = None, repr: str = "A1") -> Symmetry:
    """
    `D6 <http://symmetry.jacobs-university.de/cgi-bin/group.cgi?group=306&option=4>`_
    symmetry group.

    :param center:
        The center of the symmetry operation.

    :param repr:
        The representation of the group, chosen among 'A1', 'A2', 'B1', 'B2', 'E1' or 'E2'.
    """
    if repr == "A1":
        rot = Rotation(angle=np.pi / 3, center=center, sector=0)
        flip = Flip(center=center, sector=0)
        return rot @ flip
    if repr == "A2":
        rot = Rotation(angle=np.pi / 3, center=center, sector=0)
        flip = Flip(center=center, sector=1)
        return rot @ flip
    if repr == "B1":
        rot = Rotation(angle=np.pi / 3, center=center, sector=3)
        flip = Flip(center=center, sector=0)
        return rot @ flip
    if repr == "B2":
        rot = Rotation(angle=np.pi / 3, center=center, sector=3)
        flip = Flip(center=center, sector=1)
        return rot @ flip
    if repr == "E1":
        character = jnp.array([2, 1, -1, -2, -1, 1], get_default_dtype())
        return Rotation(angle=np.pi / 3, character=character)
    if repr == "E2":
        character = jnp.array([2, -1, -1, 2, -1, -1], get_default_dtype())
        return Rotation(angle=np.pi / 3, character=character)
    raise ValueError(
        "'repr' should be one of the following: 'A1', 'A2', 'B1', 'B2', 'E1' or 'E2'"
    )
