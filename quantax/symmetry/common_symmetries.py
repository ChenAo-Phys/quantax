from typing import Union, Sequence, Optional, Tuple
import numpy as np
import jax
import jax.numpy as jnp
from .symmetry import Symmetry
from ..global_defs import PARTICLE_TYPE, get_sites, get_lattice, get_default_dtype


_Identity = None
_Z2Inverse = dict()


def Identity() -> Symmetry:
    """Identity (no symmetry)."""
    global _Identity
    if _Identity is None:
        _Identity = Symmetry()
    return _Identity


def Z2Inversion(eigval: int = 1) -> Symmetry:
    """
    The Z2 inversion symmetry. This represents the spin flip in spin-1/2 systems,
    and the particle-hole symmetry in fermionic systems.

    :param eigval:
        An integer specifying the symmetry sector. The meaning of each number is

        - 1: Eigenvalue 1 after Z2 inversion
        - 0: No Z2 inversion symmetry
        - -1: Eigenvalue -1 after Z2 inversion
    """
    if eigval not in (1, -1):
        raise ValueError("'eigval' of Z2Inversion should be 1 or -1.")

    global _Z2Inverse
    if eigval not in _Z2Inverse:
        _Z2Inverse[eigval] = Symmetry(Z2_inversion=eigval)
    return _Z2Inverse[eigval]


def SpinInverse(eigval: int = 1) -> Symmetry:
    """
    Spin inverse symmetry for both spin-1/2 and spinful fermion systems.
    In spin systems it flips all spins.
    In spinful fermion systems it exchanges particles between spin-up and spin-down sites.

    :param eigval:
        An integer specifying the symmetry sector. The meaning of each number is

        - 1: Eigenvalue 1 after spin inversion
        - 0: No spin inversion
        - -1: Eigenvalue -1 after spin inversion
    """
    sites = get_sites()

    if not sites.is_spinful:
        raise ValueError("The `SpinInverse` is only defined for spinful systems.")

    if sites.is_fermion:
        if eigval == 1:
            sector = 0
        elif eigval == -1:
            sector = 1
        else:
            return Identity()
        N = sites.Nsites
        generator = np.concatenate([np.arange(N, 2 * N), np.arange(N)])
        return Symmetry(generator, sector)
    else:
        return Z2Inversion(eigval)


def ParticleHole(eigval: int = 1) -> Symmetry:
    """
    Particle-hole symmetry for fermion systems.

    :param eigval:
        An integer specifying the symmetry sector. The meaning of each number is

        - 1: Eigenvalue 1 after particle-hole inversion
        - 0: No particle-hole inversion
        - -1: Eigenvalue -1 after particle-hole inversion
    """
    if not get_sites().is_fermion:
        raise RuntimeError("`ParticleHole` symmetry is only for fermion systems.")
    return Z2Inversion(eigval)


def LinearTransform(
    matrix: np.ndarray, sector: int = 0, character: Optional[jax.Array] = None
) -> Symmetry:
    """
    The symmetry generated by a linear transformation to the lattice.

    :param matrix:
        A 2D array for the linear transformation matrix

    :param sector:
        The symmetry sector

    :param character:
        The eigenvalue (character) of the symmetry group elements.
        This is useful when the symmetry sector doesn't have a 1D group representation.

    .. warning::
        The users are responsible to ensure that the linear transformation generates
        a symmetry group.
    """
    tol = 1e-6
    lattice = get_lattice()

    if np.any(lattice.boundary != 1):
        raise NotImplementedError(
            "The `LinearTransorm` symmetry is only implemented for lattices with PBC."
        )

    coord = lattice.coord
    new_coord = np.einsum("ij,nj->ni", matrix, coord)
    basis = lattice.basis_vectors.T
    new_xyz = np.linalg.solve(basis, new_coord.T).T  # dimension: ni
    offsets_xyz = np.linalg.solve(basis, lattice.site_offsets.T).T  # oi
    is_integer = lambda x: np.allclose(x, np.round(x))
    if not (is_integer(new_xyz) and is_integer(offsets_xyz)):
        raise RuntimeError(
            "The `LinearTransform` doesn't generate permutation of sites."
        )

    # site n, offset o, coord i
    new_xyz = new_xyz[None, :, :] - offsets_xyz[:, None, :]
    correct_offsets = np.abs(np.round(new_xyz) - new_xyz) < tol
    correct_offsets = np.all(correct_offsets, axis=2)
    offsets_idx = np.nonzero(correct_offsets)[0]
    new_xyz = np.rint(new_xyz[correct_offsets]).astype(np.int64)

    shape = np.asarray(lattice.shape[1:])[None, ...]
    shift = new_xyz // shape
    new_xyz = new_xyz - shift * shape

    slicing = (offsets_idx,) + tuple(item for item in new_xyz.T)
    generator = lattice.index_from_xyz[slicing]
    if lattice.particle_type == PARTICLE_TYPE.spinful_fermion:
        generator = np.concatenate([generator, generator + lattice.Nsites])
    return Symmetry(generator, sector, character=character)


def Flip(axis: Union[int, Sequence] = 0, sector: int = 0) -> Symmetry:
    """
    Flip the lattice in a spatial dimension.

    :param axis:
        The axis to flip the lattice

    :param sector:
        The symmetry sector
    """
    matrix = np.ones(get_lattice().ndim)
    matrix[np.asarray(axis)] = -1
    matrix = np.diag(matrix)
    return LinearTransform(matrix, sector)


def Rotation(
    angle: float,
    axes: Sequence = (0, 1),
    sector: int = 0,
    character: Optional[jax.Array] = None,
) -> Symmetry:
    """
    Rotation symmetry.

    :param angle:
        Rotation angle

    :param axes:
        Two rotated axes

    :param sector:
        The symmetry sector

    :param character:
        The eigenvalue (character) of the symmetry group elements.
        This is useful when the symmetry sector doesn't have a 1D group representation.
    """
    ndim = get_lattice().ndim
    if max(axes) >= ndim:
        raise ValueError(
            f"The rotated axis {max(axes)} is out-of-bound for a {ndim}-D system"
        )
    cos_theta = np.cos(angle)
    sin_theta = np.sin(angle)
    matrix = np.eye(ndim)
    x, y = axes
    matrix[x, x] = cos_theta
    matrix[x, y] = -sin_theta
    matrix[y, x] = sin_theta
    matrix[y, y] = cos_theta
    return LinearTransform(matrix, sector, character=character)


def C4v(repr: str = "A1") -> Symmetry:
    """
    `C4v <http://symmetry.jacobs-university.de/cgi-bin/group.cgi?group=404&option=4>`_
    symmetry group.

    :param repr:
        The representation of the group, chosen among 'A1', 'A2', 'B1', 'B2' or 'E'.
    """
    if repr == "A1":
        return Rotation(angle=np.pi / 2, sector=0) + Flip(sector=0)
    if repr == "A2":
        return Rotation(angle=np.pi / 2, sector=0) + Flip(sector=1)
    if repr == "B1":
        return Rotation(angle=np.pi / 2, sector=2) + Flip(sector=0)
    if repr == "B2":
        return Rotation(angle=np.pi / 2, sector=2) + Flip(sector=1)
    if repr == "E":
        return Rotation(angle=np.pi, character=jnp.array([2, -2], get_default_dtype()))
    raise ValueError(
        "'repr' should be one of the following: 'A1', 'A2', 'B1', 'B2' or 'E'"
    )


def D6(repr: str = "A1") -> Symmetry:
    """
    `D6 <http://symmetry.jacobs-university.de/cgi-bin/group.cgi?group=306&option=4>`_
    symmetry group.

    :param repr:
        The representation of the group, chosen among 'A1', 'A2', 'B1', 'B2', 'E1' or 'E2'.
    """
    if repr == "A1":
        return Rotation(angle=np.pi / 3, sector=0) + Flip(sector=0)
    if repr == "A2":
        return Rotation(angle=np.pi / 3, sector=0) + Flip(sector=1)
    if repr == "B1":
        return Rotation(angle=np.pi / 3, sector=3) + Flip(sector=0)
    if repr == "B2":
        return Rotation(angle=np.pi / 3, sector=3) + Flip(sector=1)
    if repr == "E1":
        return Rotation(
            angle=np.pi / 3,
            character=jnp.array([2, 1, -1, -2, -1, 1], get_default_dtype()),
        )
    if repr == "E2":
        return Rotation(
            angle=np.pi / 3,
            character=jnp.array([2, -1, -1, 2, -1, -1], get_default_dtype()),
        )
    raise ValueError(
        "'repr' should be one of the following: 'A1', 'A2', 'B1', 'B2', 'E1' or 'E2'"
    )
