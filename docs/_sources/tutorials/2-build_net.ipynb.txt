{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "ec93cc15",
   "metadata": {},
   "source": [
    "# Build your network\n",
    "\n",
    "Variational wavefunctions in Quantax are built on [Equinox](https://github.com/patrick-kidger/equinox).\n",
    "In this tutorial, we will introduce how to build your network on Equinox, and how to test the performance of your network in Quantax."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "52c1c7c0",
   "metadata": {},
   "outputs": [],
   "source": [
    "import jax\n",
    "import jax.numpy as jnp\n",
    "import jax.random as jr\n",
    "import quantax as qtx\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "L = 8"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "503dc060",
   "metadata": {},
   "source": [
    "## Equinox quick start\n",
    "\n",
    "Equinox is a minimalist neural network library built directly on top of JAX. Unlike Flax and Haiku, which come with higher-level abstractions, Equinox emphasizes flexibility and transparency: everything is just PyTrees and functions, making it easy to integrate with raw JAX code. This means you donâ€™t have to fight against the framework when experimenting with unconventional architectures, physics-inspired models, or custom training loops.\n",
    "\n",
    "A customized Equinox network is usually like this."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "dd8c8496",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Linear(weight=f64[3,2], bias=f64[3])\n"
     ]
    }
   ],
   "source": [
    "import equinox as eqx\n",
    "\n",
    "class Linear(eqx.Module):\n",
    "    weight: jax.Array\n",
    "    bias: jax.Array\n",
    "\n",
    "    def __init__(self, in_size, out_size, key):\n",
    "        wkey, bkey = jr.split(key)\n",
    "        self.weight = jr.normal(wkey, (out_size, in_size))\n",
    "        self.bias = jr.normal(bkey, (out_size,))\n",
    "\n",
    "    def __call__(self, x):\n",
    "        return self.weight @ x + self.bias\n",
    "    \n",
    "key = jr.key(0)\n",
    "linear = Linear(2, 3, key)\n",
    "print(linear)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4f9368ed",
   "metadata": {},
   "source": [
    "`eqx.Module` has two important properties.\n",
    "\n",
    "1. It's a PyTree. In this example, `weight` and `bias` are leaves on this PyTree."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "1163466a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "weight: [[ 1.88002989 -0.48121497]\n",
      " [ 0.41545723  2.38184008]\n",
      " [-0.57536705 -0.37054353]]\n",
      "bias: [-1.4008841  1.432145   0.6248107]\n",
      "Flattened leaves: [Array([[ 1.88002989, -0.48121497],\n",
      "       [ 0.41545723,  2.38184008],\n",
      "       [-0.57536705, -0.37054353]], dtype=float64), Array([-1.4008841,  1.432145 ,  0.6248107], dtype=float64)]\n"
     ]
    }
   ],
   "source": [
    "print(\"weight:\", linear.weight)\n",
    "print(\"bias:\", linear.bias)\n",
    "\n",
    "vals, treedef = jax.tree.flatten(linear)\n",
    "print(\"Flattened leaves:\", vals)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f298ef4c",
   "metadata": {},
   "source": [
    "2. It's callable, since the `__call__` method is defined in this object."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "6037fbd3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "outputs: [-0.48328416  6.61128238 -0.69164342]\n",
      "jitted outputs: [-0.48328416  6.61128238 -0.69164342]\n",
      "jacobian: Linear(weight=f64[3,3,2], bias=f64[3,3])\n"
     ]
    }
   ],
   "source": [
    "inputs = jnp.array([1.0, 2.0])\n",
    "outputs = linear(inputs)\n",
    "\n",
    "jitted_fn = jax.jit(lambda linear, x: linear(x))  # `linear` is jittable as it's a PyTree\n",
    "jitted_outputs = jitted_fn(linear, inputs)\n",
    "jacobian = jax.jacrev(jitted_fn)(linear, inputs)\n",
    "\n",
    "print(\"outputs:\", outputs)\n",
    "print(\"jitted outputs:\", jitted_outputs)\n",
    "print(\"jacobian:\", jacobian)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1a0e188d",
   "metadata": {},
   "source": [
    "Apart from that, Equinox provides convenient filtered functions like `filter_jit` for PyTree. It's similar to `jax.jit` but available for PyTree with non-jittable leaves. See the code below for example. In Quantax, we use these filtered functions for better flexibility."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "633e7bd4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "`jax.jit` failed due to non-jittable string data type in the list.\n",
      "eqx.filter_jit successful, output:  10.0\n",
      "`jax.grad` failed due to non-jittable string data type in the list.\n",
      "eqx.filter_grad successful, gradient:  [None, None, Array([1., 1.], dtype=float64), None, Array([1., 1.], dtype=float64)]\n"
     ]
    }
   ],
   "source": [
    "def summation(l):\n",
    "    return sum(jnp.sum(x) for x in l if isinstance(x, jax.Array))\n",
    "\n",
    "l = [1, 2.0, jnp.array([1.0, 2.0]), \"string\", jnp.array([3.0, 4.0])]\n",
    "\n",
    "try:\n",
    "    out = jax.jit(summation)(l)\n",
    "except TypeError as e:\n",
    "    print(\"`jax.jit` failed due to non-jittable string data type in the list.\")\n",
    "\n",
    "out = eqx.filter_jit(summation)(l)\n",
    "print(\"eqx.filter_jit successful, output: \", out)\n",
    "\n",
    "try:\n",
    "    g = jax.grad(summation)(l)\n",
    "except TypeError as e:\n",
    "    print(\"`jax.grad` failed due to non-jittable string data type in the list.\")\n",
    "\n",
    "g = eqx.filter_grad(summation)(l)\n",
    "print(\"eqx.filter_grad successful, gradient: \", g)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bf06c9d4",
   "metadata": {},
   "source": [
    "## Build wavefunction\n",
    "\n",
    "Let's start by building the following variational wavefunction\n",
    "\n",
    "$$\n",
    "x^{(1)} = \\mathrm{ReLU}(W^{(1)} s + b^{(1)}) \\\\\n",
    "x^{(2)} = W^{(2)} x^{(1)} + b^{(2)} \\\\\n",
    "\\psi = \\sum \\exp(x^{(2)})\n",
    "$$\n",
    "where the network has an array input $s$ and a scalar output $\\psi$, and $W^{(1)}$, $b^{(1)}$, $W^{(2)}$, and $b^{(2)}$ are variational parameters."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "41f4d5f5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "MyModel(\n",
      "  layer1=Linear(\n",
      "    weight=f64[16,8],\n",
      "    bias=f64[16],\n",
      "    in_features=8,\n",
      "    out_features=16,\n",
      "    use_bias=True\n",
      "  ),\n",
      "  layer2=Linear(\n",
      "    weight=f64[16,16],\n",
      "    bias=f64[16],\n",
      "    in_features=16,\n",
      "    out_features=16,\n",
      "    use_bias=True\n",
      "  )\n",
      ")\n"
     ]
    }
   ],
   "source": [
    "import equinox as eqx\n",
    "\n",
    "class MyModel(eqx.Module):\n",
    "    layer1: eqx.nn.Linear  # eqx.nn.Linear is a built-in linear layer\n",
    "    layer2: eqx.nn.Linear\n",
    "\n",
    "    def __init__(self, in_size: int, width: int):\n",
    "        keys = qtx.get_subkeys(2)  # Convenient function in Quantax to provide keys\n",
    "        layer1 = eqx.nn.Linear(in_size, width, key=keys[0])\n",
    "        self.layer1 = qtx.nn.apply_he_normal(keys[0], layer1)  # He initialization\n",
    "        layer2 = eqx.nn.Linear(width, width, key=keys[1])\n",
    "        self.layer2 = qtx.nn.apply_lecun_normal(keys[1], layer2)  # LeCun initialization\n",
    "\n",
    "    def __call__(self, x):\n",
    "        x = jax.nn.relu(self.layer1(x))\n",
    "        x = self.layer2(x)\n",
    "        psi = jnp.sum(jnp.exp(x))\n",
    "        return psi\n",
    "\n",
    "model = MyModel(in_size=L, width=16)\n",
    "print(model)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f3f0ab65",
   "metadata": {},
   "source": [
    "We can test it by making a forward pass."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "36df2edf",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "psi = 25.80643431025371\n"
     ]
    }
   ],
   "source": [
    "s = jnp.ones(L)\n",
    "psi = model(s)\n",
    "print(\"psi =\", psi)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "80fb5455",
   "metadata": {},
   "source": [
    "Now let's use this new network in Quantax. One should wrap the network by {py:class}`~quantax.state.Variational` to use it as a variational state. It supports batched forward pass."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "2914ef8d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of parameters: 416\n",
      "psi = [32.53068691 27.79913187 15.22629544 19.97114671 34.05009489 15.61717887\n",
      " 22.10967177 21.51156317]\n"
     ]
    }
   ],
   "source": [
    "lattice = qtx.sites.Chain(L)\n",
    "state = qtx.state.Variational(model)\n",
    "\n",
    "print(\"Number of parameters:\", state.nparams)\n",
    "\n",
    "s = qtx.utils.rand_states(8)  # 8 random spin configurations\n",
    "psi = state(s)  # Batched forward pass\n",
    "print(\"psi =\", psi)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f7995f5d",
   "metadata": {},
   "source": [
    "## Test by exact reconfiguration\n",
    "\n",
    "Exact reconfiguration (ER) is an optimization method that approximates imaginary-time evolution without Monte Carlo samples, which is only available in small systems. We can use {py:class}`~quantax.optimizer.ER` to rapidly test the expressive power of neural networks."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "6e01ed7c",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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33nnHU2ePFknTpxQVlaWJGnRokV64IEHdPr0aTmdzjO+1549ezR48GBt2rRJo0aNkiQtX75cN910k44dO6bc3Nx21cQQVffj9nj154+P6qlVB1RW2yhJ6psRp3uu668pw3PlsDPfHgA6u04xRHUu69ev19ChQwPhRpImTJigyspK7dq1q9VzkpOTA+FGksaNGyebzaYNGza0+lput1uVlZUtDnQvLoddd16drw/uv073jb9ISTFR+vx0jX786nbd8MT7+uumo3J72N8KACKFZQGnsLCwRbiRFPi6sLCw1XMyMzNbPOZwOJSamtrqOZI0f/58JSUlBY68vLwLrB5dVUJ0lP6/GwZo3QPX6f6JA5USG6UjJbV64P926Opfr9bC1QdV0dTDAwDoujoUcObNmyfDMNo89u7dG6paz9uDDz6oioqKwFFQUGB1SbBYQnSU7r62v9Y9cL1+etMgZSdG63SVW4+/u09jF6zUL9/apSMlNVaXCQA4T46ONL7vvvs0c+bMNtv07du3Xd8rOztbGzdubPFYUVFR4LnWzjl16lSLxzwej0pLS1s9R5JcLpdcLle76kL3Eudy6K6v9tPMK/O17NMTeu6Dz7W3sEovfHhYL350WNdclKEZY/vomosyZLMZVpcLAGinDgWcjIwMZWRkBOWFx44dq0ceeUSnTp0KDDutWLFCiYmJGjx4cKvnlJeXa8uWLRo5cqQkadWqVfL5fBozZkxQ6kL35HTY9I3LeurrI3po3cFi/WntIb2//7TW7PMfvVJjNX1ML31zZE+lxxOWAaCzC9ldVEePHlVpaanefPNNPf7441q7dq0kqX///oqPj5fX69Wll16q3NxcPfbYYyosLNRtt92mf//3f9ejjz4qSdq4caNuv/12rVy5Uj169JAk3XjjjSoqKtKiRYvU2NioO+64Q6NGjdJf/vKXdtfGXVRoj8PFNfrzx0f06uYCVdb712dy2AyNH5ylfxudp68MyJCdXh0ACJtOsZLxzJkztXjx4jMeX716ta699lpJ0pEjRzRr1iytWbNGcXFxmjFjhhYsWCCHw9+xtGbNGl133XU6dOiQ+vTpI8m/0N8999yjt956SzabTd/85jf15JNPKj4+vt21EXDQEbUNHr35yQm9vKlA2wvKA4/nJkXr65f10NdH9FT/zPb/+wMAnJ9OEXA6MwIOztfewkr9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nU5FRUV1uK3X61V9feu9HFFRUXI6nR1u6/P5VFfX+tBSR9o6HA65XC5J/gnQtbW1bbZNj3cpPd71pbYxZ23b1s+912eqrtGr2gb/Uecx5ZVdtY1e1TV4VVZVq9oGr+ob/WGortGnukav6ht9qvf41OjVF+e7G+X2+OT2+FTf1Mbt8an5p9tnqul7tP7zYxWb4V8t22G3+T/a/AHJYfOHILsh2Q3D/3nT81/+6IpyyG6zyW6TDNMMfD/bl9rZDH+odTmdgefk88mQTzbD+KK9Ychm879etMslu93/mM/nlXw+2W2GjKZ6bE3f12YYio52yWG3yWYY8nk98nm9gdc0DP97MAx/+5joaDnsdtlsktfjkdfjka3pueY2NsOQmtpGOewyDMnb6JHH0yib4a+h+aO/qaHYGP/vCJthyOtpVGNjY+B7/rNw/I6wEgEnBOLjW58ncNNNN+nvf/974OvMzMxWf4lec801WrNmTeDrPn36qLi4+KxtR40apU2bNgW+Hjx4sI4cOXLWtoMHD9auXbsCX48ePVq7d+8+a9vevXvr8OHDga+/+tWvavPmzWdtm56ertOnTwe+vvHGG/X++++ftW1sbGyLX/Lf/OY39fbbb5+1raQWAey2227T//7v/7batrq6OhCIvv/972vx4sWttj116pQyMjIkST/+8Y/19NNPt9r20KFD6tOnjyTpoYce0m9+85tW2+7cuVNDhgyRJD366KP65S9/2WrbjRs3avTo0ZKk3//+97r//vtbbbt69Wpde+21kqTnnntO99xzT6ttly1bpkmTJkmSXnrpJd1xxx2ttn311Vd1yy23SJKWLl2qf/3Xf2217QsvvKCZM2dKkt59911Nnjy51bZPPfWUZs+eLUlau3atrrvuulbbPvbYY5o7d64kaevWrbr88stbbfuLX/xC//Ef/yFJ2rNnjy655JJW2/7kJz/R448/Lkk6evSo8vPzW2179913a+HChZKk4uJiZWZmttp2xowZevHFFyX5/5PQ1s/9v/zLv+i1114LfN2R3xFxcXHt/h2RkZFx9t8RdocuG32F3nl3RVMA8mrc125UYXGJDIdLskfJsEfJcETJcDiV27OX5v30Z3J7fGrw+PTUM8+ouKzC38buaPoYJdkdiotP1FeuvU5uj08er0+f7tyt2nq3DLvD/31t9sDnNnuUnNHRavSe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",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "H = qtx.operator.Ising(h=1.0)\n",
    "E, wf = H.diagonalize()\n",
    "exact_state = qtx.state.DenseState(wf)\n",
    "\n",
    "optimizer = qtx.optimizer.ER(state, H)\n",
    "\n",
    "energy = qtx.utils.DataTracer()\n",
    "training_rate = 0.02\n",
    "\n",
    "for i in range(100):\n",
    "    step = optimizer.get_step()\n",
    "    state.update(step * training_rate)\n",
    "    energy.append(optimizer.energy)\n",
    "\n",
    "energy.plot(baseline=E)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "abc51f2c",
   "metadata": {},
   "source": [
    "In small systems, we can transform {py:class}`~quantax.state.Variational` to {py:class}`~quantax.state.DenseState` to check its overlap with the exact ground state."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "fdcb03f7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Overlap with the exact ground state: 0.998887139941578\n"
     ]
    }
   ],
   "source": [
    "dense = state.todense().normalize()\n",
    "overlap = abs(dense @ exact_state)\n",
    "print(\"Overlap with the exact ground state:\", overlap)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d76a5dae",
   "metadata": {},
   "source": [
    "Now we have a nice neural quantum state for solving the Ising model!"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5eb3f108",
   "metadata": {},
   "source": [
    "## Avoid overflow\n",
    "\n",
    "In neural quantum state simulations, we often have very large wavefunctions beyond the range of float64. Here is an example."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "dbe7152c",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Array(inf, dtype=float64)"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "model = MyModel(in_size=L, width=16)\n",
    "\n",
    "W1 = model.layer1.weight\n",
    "W2 = model.layer2.weight\n",
    "\n",
    "# Manually multiply weights by 100 to cause overflow\n",
    "model = eqx.tree_at(lambda model: model.layer1.weight, model, W1 * 100)\n",
    "model = eqx.tree_at(lambda model: model.layer2.weight, model, W2 * 100)\n",
    "\n",
    "s = qtx.utils.rand_states()\n",
    "model(s)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "27b63c60",
   "metadata": {},
   "source": [
    "To avoid this problem, we define two customized data types, {py:class}`~quantax.utils.LogArray` and {py:class}`~quantax.utils.ScaleArray`, to store large values. They are also accepted as network outputs in Quantax. Instead of using dangerous functions like `jnp.exp` that might cause overflow, one can use {py:func}`qtx.nn.exp_by_scale` to output safe values expressed by {py:class}`~quantax.utils.ScaleArray`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "72d26ff7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ScaleArray(\n",
      "  significand=1.0,\n",
      "  exponent=15694.038701452486\n",
      ")\n"
     ]
    }
   ],
   "source": [
    "class NewModel(eqx.Module):\n",
    "    layer1: eqx.nn.Linear\n",
    "    layer2: eqx.nn.Linear\n",
    "\n",
    "    def __init__(self, in_size: int, width: int):\n",
    "        keys = qtx.get_subkeys(2)\n",
    "        layer1 = eqx.nn.Linear(in_size, width, key=keys[0])\n",
    "        self.layer1 = qtx.nn.apply_he_normal(keys[0], layer1)\n",
    "        layer2 = eqx.nn.Linear(width, width, key=keys[1])\n",
    "        self.layer2 = qtx.nn.apply_lecun_normal(keys[1], layer2)\n",
    "\n",
    "    def __call__(self, x):\n",
    "        x = jax.nn.relu(self.layer1(x))\n",
    "        x = self.layer2(x)\n",
    "        # Dangerous: psi = jnp.sum(jnp.exp(x))\n",
    "        # Safe:\n",
    "        psi = qtx.nn.exp_by_scale(x).sum()\n",
    "        return psi\n",
    "    \n",
    "\n",
    "model = NewModel(in_size=L, width=16)\n",
    "model = eqx.tree_at(lambda model: model.layer1.weight, model, W1 * 100)\n",
    "model = eqx.tree_at(lambda model: model.layer2.weight, model, W2 * 100)\n",
    "\n",
    "psi = model(s)\n",
    "print(psi)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d9ddaa0b",
   "metadata": {},
   "source": [
    "Here the output {py:class}`~quantax.utils.ScaleArray` is a PyTree with significand $x$ and exponent $\\theta$. The true expressed value is $x e^\\theta$, which is beyond the range of float64. In most calculations, this quantity can be treated like an ordinary array object, as shown below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "8b4044be",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Reshape psi: ScaleArray(\n",
      "  significand=[[1. 1. 1. 1.]\n",
      " [1. 1. 1. 1.]],\n",
      "  exponent=15694.038701452486\n",
      ")\n",
      "Sum psi: ScaleArray(\n",
      "  significand=[4. 4.],\n",
      "  exponent=15694.038701452486\n",
      ")\n",
      "Power psi: ScaleArray(\n",
      "  significand=[1.00013864 1.00013864],\n",
      "  exponent=1.5694038701452486\n",
      ")\n",
      "To jax Array: [4.80444965 4.80444965]\n"
     ]
    }
   ],
   "source": [
    "psi = psi.repeat(8).reshape(2, 4)\n",
    "print(\"Reshape psi:\", psi)\n",
    "\n",
    "psi = psi.sum(axis=1)\n",
    "print(\"Sum psi:\", psi)\n",
    "\n",
    "psi = psi ** (1 / 10000)\n",
    "print(\"Power psi:\", psi)\n",
    "\n",
    "psi = jnp.asarray(psi)\n",
    "print(\"To jax Array:\", psi)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "60552d11",
   "metadata": {},
   "source": [
    "However, JAX doesn't have a full support for [customized arrays](https://docs.jax.dev/en/latest/jep/28661-jax-array-protocol.html), so one should be careful when using these customized arrays. Here we list several possible problems.\n",
    "\n",
    "1. Manipulations like `jnp.fn(array)` transform customized arrays to `jax.Array`, causing overflow. To avoid it, call `array.fn()`.\n",
    "\n",
    "2. Computations like `jax_array * customized_array` always call `jax_array.__mul__(customized_array)`, which returns a `jax.Array` that might cause overflow. To avoid it, use `customized_array * jax_array`.\n",
    "\n",
    "Here are some examples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "d2366af8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Wrong sum: nan\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Correct sum: ScaleArray(\n",
      "  significand=6.0,\n",
      "  exponent=10000.0\n",
      ")\n",
      "Wrong mul: [nan inf inf inf]\n",
      "Correct mul: ScaleArray(\n",
      "  significand=[0.         0.33333333 1.33333333 3.        ],\n",
      "  exponent=10001.098612288668\n",
      ")\n"
     ]
    }
   ],
   "source": [
    "significand = jnp.array([0.0, 1.0, 2.0, 3.0])\n",
    "exponent = jnp.array(10000.0)\n",
    "psi = qtx.utils.ScaleArray(significand, exponent)\n",
    "\n",
    "print(\"Wrong sum:\", jnp.sum(psi))\n",
    "print(\"Correct sum:\", psi.sum())\n",
    "\n",
    "a = jnp.arange(4)\n",
    "print(\"Wrong mul:\", a * psi)\n",
    "print(\"Correct mul:\", psi * a)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "quantax_env",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
